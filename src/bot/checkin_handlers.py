"""
Handlers para os comandos de check-in.
"""
import logging
from typing import Optional, Dict, Any
from telegram import Update
from telegram.ext import ContextTypes
from telegram.constants import ParseMode
from telegram.error import TimedOut
from src.utils.mongodb_instance import mongodb_client
from src.bot.handlers import is_admin, send_temporary_message, delete_message_after
import asyncio
from datetime import datetime

# Configura√ß√£o de logging
logger = logging.getLogger(__name__)

async def checkin_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handler para o comando /checkin.
    Define uma mensagem como √¢ncora de check-in.
    
    Args:
        update (Update): Objeto de atualiza√ß√£o do Telegram.
        context (ContextTypes.DEFAULT_TYPE): Contexto do callback.
    """
    # Verifica se o usu√°rio √© administrador
    if not await is_admin(update, context):
        await send_temporary_message(
            update, 
            context, 
            "Apenas administradores podem usar este comando."
        )
        return
    
    # Verifica se o comando foi usado como resposta a outra mensagem
    if not update.message.reply_to_message:
        await send_temporary_message(
            update, 
            context, 
            "Por favor, use este comando respondendo √† mensagem que deseja definir como check-in."
        )
        return
    
    # Obt√©m os IDs do chat e da mensagem
    chat_id = update.effective_chat.id
    message_id = update.message.reply_to_message.message_id
    
    # Define a mensagem como √¢ncora de check-in
    success = await mongodb_client.set_checkin_anchor(chat_id, message_id)
    
    if success:
        # Tenta deletar a mensagem de comando
        try:
            await update.message.delete()
        except Exception as e:
            logger.error(f"Erro ao deletar mensagem de comando: {e}")
        
        # Envia mensagem de confirma√ß√£o
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚úÖ Check-in ativado! Os membros podem responder √† mensagem marcada para registrar seu check-in di√°rio.",
            reply_to_message_id=message_id
        )
    else:
        await send_temporary_message(
            update, 
            context, 
            "‚ùå Erro ao ativar o check-in. Por favor, tente novamente."
        )

async def endcheckin_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handler para o comando /endcheckin.
    Desativa o check-in atual.
    
    Args:
        update (Update): Objeto de atualiza√ß√£o do Telegram.
        context (ContextTypes.DEFAULT_TYPE): Contexto do callback.
    """
    # Verifica se o usu√°rio √© administrador
    if not await is_admin(update, context):
        await send_temporary_message(
            update, 
            context, 
            "Apenas administradores podem usar este comando."
        )
        return
    
    # Obt√©m o ID do chat
    chat_id = update.effective_chat.id
    
    # Obt√©m o check-in ativo antes de desativ√°-lo
    active_checkin = await mongodb_client.get_active_checkin(chat_id)
    
    if not active_checkin:
        await send_temporary_message(
            update, 
            context, 
            "N√£o h√° check-in ativo para desativar."
        )
        return
    
    # Obt√©m a contagem de check-ins para a √¢ncora ativa
    anchor_id = active_checkin["_id"]
    checkin_count = await mongodb_client.get_anchor_checkin_count(chat_id, anchor_id)
    
    # Desativa o check-in atual
    success = await mongodb_client.end_checkin(chat_id)
    
    if success:
        # Tenta deletar a mensagem de comando
        try:
            await update.message.delete()
        except Exception as e:
            logger.error(f"Erro ao deletar mensagem de comando: {e}")
        
        # Envia mensagem de confirma√ß√£o com a contagem de check-ins
        await context.bot.send_message(
            chat_id=chat_id,
            text=f"‚úÖ Check-in antigo finalizado! Foram registrados {checkin_count} check-ins."
        )
    else:
        await send_temporary_message(
            update, 
            context, 
            "‚ùå Erro ao desativar o check-in. Por favor, tente novamente."
        )

async def handle_checkin_response(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handler para respostas a mensagens de check-in.
    
    Args:
        update (Update): Objeto de atualiza√ß√£o do Telegram.
        context (ContextTypes.DEFAULT_TYPE): Contexto do callback.
    """
    # Se a mensagem n√£o for uma resposta, retorna
    if not update.message.reply_to_message:
        return
    
    # Verifica se a mensagem cont√©m m√≠dia (foto, v√≠deo, GIF, etc.)
    if not (update.message.photo or update.message.video or 
            update.message.animation or 
            (update.message.document and update.message.document.mime_type and 
             update.message.document.mime_type.startswith('image/'))):
        logger.debug(f"Mensagem de check-in sem m√≠dia ignorada: {update.message.message_id}")
        return
    
    # Obt√©m o chat_id e o replied_message_id
    chat_id = update.effective_chat.id
    replied_message_id = update.message.reply_to_message.message_id
    
    # Obt√©m o check-in ativo
    active_checkin = await mongodb_client.get_active_checkin(chat_id)
    
    # Se n√£o houver check-in ativo, retorna
    if not active_checkin:
        return
    
    # Se a mensagem n√£o for uma resposta √† mensagem √¢ncora de check-in, retorna
    if active_checkin["message_id"] != replied_message_id:
        logger.debug(f"Ignorando mensagem: resposta n√£o √© para a √¢ncora de check-in. √Çncora: {active_checkin['message_id']}, Resposta para: {replied_message_id}")
        return
    
    logger.info(f"Check-in detectado de {update.effective_user.full_name} ({update.effective_user.id}) no chat {chat_id}")
    
    # Obt√©m informa√ß√µes do usu√°rio
    user_id = update.effective_user.id
    user_name = update.effective_user.full_name or "Usu√°rio"
    username = update.effective_user.username  # Captura o username
    
    # Registra o check-in do usu√°rio
    checkin_count = await mongodb_client.record_user_checkin(chat_id, user_id, user_name, username)
    
    # Se o usu√°rio j√° fez check-in para esta √¢ncora, retorna None
    if checkin_count is None:
        logger.debug(f"Usu√°rio {user_id} j√° fez check-in para esta √¢ncora")
        # Use username para exibi√ß√£o se dispon√≠vel
        display_name = f"@{username}" if username else user_name
        await send_temporary_message(
            update, 
            context, 
            f"Voc√™ j√° fez seu check-in para esta mensagem, {display_name}! üòâ"
        )
        return
    
    logger.info(f"Check-in registrado com sucesso. Total de check-ins do usu√°rio: {checkin_count}")
    
    # Adiciona rea√ß√£o de fogo √† mensagem do usu√°rio
    try:
        await context.bot.set_message_reaction(
            chat_id=chat_id,
            message_id=update.message.message_id,
            reaction=["üî•"]
        )
    except Exception as e:
        logger.error(f"Erro ao adicionar rea√ß√£o √† mensagem: {e}")
    
    # Gera uma mensagem de resposta personalizada
    # Use username para exibi√ß√£o se dispon√≠vel
    display_name = f"@{username}" if username else user_name
    response_message = generate_checkin_response(display_name, checkin_count)
    
    # Responde ao usu√°rio com uma mensagem permanente (sem usar send_temporary_message)
    await update.message.reply_text(response_message, parse_mode=ParseMode.HTML)

async def checkinscore_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handler para o comando /checkinscore.
    Envia um scoreboard com os check-ins dos usu√°rios.
    
    Args:
        update (Update): Objeto de atualiza√ß√£o do Telegram.
        context (ContextTypes.DEFAULT_TYPE): Contexto do callback.
    """
    # Determina o chat para o qual exibir o scoreboard
    chat_id = update.effective_chat.id
    chat_title = None
    
    # Verifica se um nome de grupo foi fornecido como argumento
    if context.args and len(context.args) > 0:
        target_group_name = ' '.join(context.args)
        target_chat_id = await mongodb_client._get_chat_id_by_name(target_group_name)
        
        if target_chat_id:
            chat_id = target_chat_id
            chat_title = target_group_name
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"N√£o foi poss√≠vel encontrar o grupo '{target_group_name}'. Verifique o nome e tente novamente."
            )
            return
    
    # Obt√©m o scoreboard de check-ins
    scoreboard = await mongodb_client.get_checkin_scoreboard(chat_id)
    
    # Tenta deletar a mensagem de comando
    try:
        await update.message.delete()
    except Exception as e:
        logger.error(f"Erro ao deletar mensagem de comando: {e}")
    
    if not scoreboard or len(scoreboard) == 0:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"Ainda n√£o h√° check-ins registrados {f'no grupo {chat_title}' if chat_title else 'neste chat'}. üò¢"
        )
        return
    
    # Obt√©m estat√≠sticas adicionais
    total_participants = await mongodb_client.get_total_checkin_participants(chat_id)
    first_checkin_date = await mongodb_client.get_first_checkin_date(chat_id)
    total_checkins = await mongodb_client.count_total_checkins(chat_id)
    
    # Calcula h√° quantos dias o primeiro check-in foi registrado
    days_since_first_checkin = None
    if first_checkin_date:
        days_since_first_checkin = (datetime.now() - first_checkin_date).days
    
    # Limita o scoreboard a no m√°ximo 15 usu√°rios
    scoreboard = scoreboard[:15]
    
    # Cria a mensagem do scoreboard com o novo design visual
    message = f"üèÜ <b>GYM NATION CHECK-INS</b> üèÜ\n\n"
    
    # Agrupa usu√°rios com a mesma contagem
    grouped_scoreboard = {}
    for i, user in enumerate(scoreboard):
        count = user['count']
        if count not in grouped_scoreboard:
            grouped_scoreboard[count] = []
        grouped_scoreboard[count].append(user)
    
    # Adiciona usu√°rios ao scoreboard
    current_position = 1
    for count, users in sorted(grouped_scoreboard.items(), key=lambda x: x[0], reverse=True):
        # Atribui medalha com base na posi√ß√£o
        if current_position == 1:
            medal = "ü•á "
        elif current_position == 2:
            medal = "ü•à "
        elif current_position == 3:
            medal = "ü•â "
        else:
            medal = "üîπ "
        
        # Processa usu√°rios com o novo formato
        if len(users) > 1:
            message += f"{medal}<b>{current_position}.</b> (<b>{count}</b> check-ins)\n"
            # Lista cada usu√°rio empatado em sua pr√≥pria linha com um √≠cone
            for user in users:
                display_name = f"@{user['username']}" if user['username'] else user['user_name']
                message += f"    üë§ {display_name}\n"
        else:
            user = users[0]
            display_name = f"@{user['username']}" if user['username'] else user['user_name']
            message += f"{medal}<b>{current_position}.</b> {display_name}: <b>{count}</b> check-ins\n"
        
        # Incrementa a posi√ß√£o pelo n√∫mero de usu√°rios na posi√ß√£o atual
        current_position += len(users)
    
    # Adiciona mensagem motivacional
    message += "\nüí™ Continue mantendo a consist√™ncia! üî•\n"
    
    # Adiciona estat√≠sticas com formata√ß√£o melhorada
    if total_participants and days_since_first_checkin is not None:
        message += "\nüìä <b>Estat√≠sticas:</b>\n"
        message += f"‚Ä¢ <b>{total_participants}</b> pessoas j√° participaram\n"
        message += f"‚Ä¢ <b>{total_checkins}</b> check-ins no total\n"
        message += f"‚Ä¢ Primeiro check-in: <b>{days_since_first_checkin}</b> dias atr√°s"
    
    # Envia a mensagem para o chat atual (n√£o para o chat_id consultado)
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=message,
        parse_mode=ParseMode.HTML
    )

def generate_checkin_response(user_name: str, checkin_count: int) -> str:
    """
    Gera uma mensagem de resposta personalizada com base no n√∫mero de check-ins do usu√°rio.
    
    Args:
        user_name (str): Nome do usu√°rio.
        checkin_count (int): N√∫mero de check-ins do usu√°rio.
        
    Returns:
        str: Mensagem personalizada.
    """
    # Mensagens personalizadas com base no n√∫mero de check-ins
    if checkin_count == 1:
        return f"<b>Primeiro</b> check-in de {user_name}! üéâ Bem-vindo ao GYM NATION!"
    elif checkin_count == 3:
        return f"<b>Terceiro</b> check-in de {user_name}! üî• Voc√™ est√° criando consist√™ncia!"
    elif checkin_count == 5:
        return f"<b>Quinto</b> check-in de {user_name}! üí™ Voc√™ est√° no caminho certo!"
    elif checkin_count == 10:
        return f"Uau! {user_name} j√° est√° no check-in #<b>10</b>! Sua consist√™ncia √© inspiradora! üî•"
    elif checkin_count == 30:
        return f"Um <b>m√™s</b> de check-ins! {user_name} est√° construindo um h√°bito incr√≠vel! üèÜ"
    elif checkin_count == 100:
        return f"INACREDIT√ÅVEL! {user_name} alcan√ßou <b>100</b> check-ins! Voc√™ √© uma lenda! üëë"
    elif checkin_count % 50 == 0:
        return f"WOW! {user_name} atingiu <b>{checkin_count}</b> check-ins! Que dedica√ß√£o impressionante! üåü"
    elif checkin_count % 25 == 0:
        return f"Parab√©ns, {user_name}! Voc√™ alcan√ßou <b>{checkin_count}</b> check-ins! Continue assim! üöÄ"
    elif checkin_count % 10 == 0:
        return f"Mais um marco! {user_name} completou <b>{checkin_count}</b> check-ins! üíØ"
    else:
        # Mensagens aleat√≥rias para outros n√∫meros de check-in
        messages = [
            f"Check-in #<b>{checkin_count}</b> registrado para {user_name}! üí™",
            f"{user_name} est√° em chamas! üî• Check-in #<b>{checkin_count}</b>!",
            f"Mais um dia, mais um check-in para {user_name}! #<b>{checkin_count}</b> üèãÔ∏è",
            f"A consist√™ncia de {user_name} √© admir√°vel! Check-in #<b>{checkin_count}</b> üëè",
            f"{user_name} n√£o para! Check-in #<b>{checkin_count}</b> registrado! üöÄ"
        ]
        return messages[checkin_count % len(messages)]

async def confirmcheckin_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Comando para confirmar manualmente um check-in que n√£o foi processado automaticamente.
    Deve ser usado por um administrador respondendo √† mensagem de um usu√°rio.
    
    Args:
        update (Update): Objeto de atualiza√ß√£o do Telegram.
        context (ContextTypes.DEFAULT_TYPE): Contexto do callback.
    """
    # Verifica se o usu√°rio √© administrador
    if not await is_admin(update, context):
        await send_temporary_message(
            update, 
            context, 
            "Apenas administradores podem usar este comando."
        )
        return
    
    # Verifica se o comando foi usado como resposta a outra mensagem
    if not update.message.reply_to_message:
        await send_temporary_message(
            update, 
            context, 
            "Por favor, use este comando respondendo √† mensagem do usu√°rio para confirmar o check-in."
        )
        return
    
    # Obt√©m os IDs do chat e da mensagem
    chat_id = update.effective_chat.id
    target_message = update.message.reply_to_message
    target_user_id = target_message.from_user.id
    target_user_name = target_message.from_user.full_name or f"@{target_message.from_user.username}" or "Usu√°rio"
    target_username = target_message.from_user.username  # Captura o username
    
    # Verifica se h√° um check-in ativo
    try:
        active_checkin = await mongodb_client.get_active_checkin(chat_id)
        
        if not active_checkin:
            await send_temporary_message(
                update, 
                context, 
                "N√£o h√° check-in ativo neste momento. Use /checkin para ativar um."
            )
            return
        
        # Registra o check-in do usu√°rio
        checkin_count = await mongodb_client.record_user_checkin(chat_id, target_user_id, target_user_name, target_username)
        
        # Se o usu√°rio j√° fez check-in, envia mensagem e retorna
        if checkin_count is None:
            # Armazena a mensagem tempor√°ria antes de deletar o comando
            temp_message = await context.bot.send_message(
                chat_id=chat_id,
                text=f"{target_user_name} j√° fez check-in para a √¢ncora atual. üòâ",
                reply_to_message_id=target_message.message_id
            )
            
            # Agenda a exclus√£o da mensagem tempor√°ria
            asyncio.create_task(delete_message_after(temp_message, 20))
            
            # Tenta deletar a mensagem de comando
            try:
                await update.message.delete()
            except Exception as e:
                logger.error(f"Erro ao deletar mensagem de comando: {e}")
                
            return
        
        logger.info(f"Check-in manual registrado para {target_user_name} ({target_user_id}). Total: {checkin_count}")
        
        # Adiciona uma rea√ß√£o √† mensagem do usu√°rio para confirmar o check-in
        try:
            await context.bot.set_message_reaction(
                chat_id=chat_id,
                message_id=target_message.message_id,
                reaction=["üî•"]
            )
            
            # Gera e envia uma mensagem de confirma√ß√£o personalizada
            response_message = generate_checkin_response(target_user_name, checkin_count)
            await context.bot.send_message(
                chat_id=chat_id,
                text=response_message,
                reply_to_message_id=target_message.message_id,
                parse_mode=ParseMode.HTML
            )
            
            # Tenta deletar a mensagem de comando DEPOIS de enviar a resposta
            try:
                await update.message.delete()
            except Exception as e:
                logger.error(f"Erro ao deletar mensagem de comando: {e}")
                
        except Exception as reaction_error:
            logger.error(f"Erro ao adicionar rea√ß√£o √† mensagem: {reaction_error}")
            # Apenas envia mensagem de confirma√ß√£o se houver erro na rea√ß√£o
            if not isinstance(reaction_error, TimedOut):
                # Gera e envia uma mensagem de confirma√ß√£o personalizada
                response_message = generate_checkin_response(target_user_name, checkin_count)
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=response_message,
                    reply_to_message_id=target_message.message_id,
                    parse_mode=ParseMode.HTML
                )
                
                # Tenta deletar a mensagem de comando DEPOIS de enviar a resposta
                try:
                    await update.message.delete()
                except Exception as e:
                    logger.error(f"Erro ao deletar mensagem de comando: {e}")
                
    except Exception as db_error:
        logger.error(f"Erro ao registrar check-in no banco de dados: {db_error}")
        
        # Envia mensagem de erro antes de tentar deletar o comando
        temp_message = await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå Erro ao registrar check-in. Por favor, tente novamente.",
            reply_to_message_id=target_message.message_id
        )
        
        # Agenda a exclus√£o da mensagem tempor√°ria
        asyncio.create_task(delete_message_after(temp_message, 20))
        
        # Tenta deletar a mensagem de comando
        try:
            await update.message.delete()
        except Exception as e:
            logger.error(f"Erro ao deletar mensagem de comando: {e}") 